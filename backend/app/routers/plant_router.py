# Z:\Main\github-repos\gardening_app\backend\app\routers\plant_router.py
# Standard library imports for FastAPI functionality
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import List, Optional
import logging

# Import our database models and connection utilities
# These connect to our PostgreSQL database running in Docker
from .. import models
from ..database import get_db

# Configure logging to show debug level messages
# This helps track database operations and API requests
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


# Define the Plant data model using Pydantic
# This creates a schema that validates the data structure for plants
class PlantSchema(BaseModel):
    name: str  # Required: Name of the plant
    description: str  # Required: Description of the plant
    watering_schedule: str  # Required: Watering schedule for the plant
    id: Optional[int] = None  # Optional: ID will be auto-generated by PostgreSQL

    # Enable ORM mode for Pydantic
    # This allows automatic conversion between SQLAlchemy models and JSON
    class Config:
        orm_mode = True


# Create a FastAPI router to handle plant-related endpoints
# This router will be included in main.py under the /api/v1 prefix
router = APIRouter()

# The following endpoints implement CRUD (Create, Read, Update, Delete) operations for plants.
# Each endpoint uses dependency injection to get a database session (db: Session = Depends(get_db)).
# All endpoints use SQLAlchemy ORM to interact with the PostgreSQL database.


# GET endpoint to retrieve all plants from PostgreSQL
# Route: GET /api/v1/plants
@router.get("/plants", response_model=List[PlantSchema])
def get_plants(db: Session = Depends(get_db)):  # Inject database session
    """
    Returns all plants from the PostgreSQL database.
    Uses SQLAlchemy ORM for database queries.

    Args:
        db (Session): Database session (automatically injected by FastAPI)

    Returns:
        List[PlantSchema]: All plants in the database
    """
    logger.debug("Fetching all plants from PostgreSQL database")
    # Query all plants using SQLAlchemy
    plants = db.query(models.Plant).all()
    logger.debug(f"Found {len(plants)} plants in database")
    return plants


# POST endpoint to add a new plant to PostgreSQL
# Route: POST /api/v1/plants
@router.post("/plants", response_model=PlantSchema)
async def add_plant(
    plant: PlantSchema,  # Request body validated against PlantSchema model
    db: Session = Depends(get_db),  # Database session
):
    """
    Adds a new plant to the PostgreSQL database.
    Includes duplicate name checking and data validation.

    Args:
        plant (PlantSchema): Plant data from request body
        db (Session): Database session for PostgreSQL

    Returns:
        PlantSchema: Newly created plant with database ID

    Raises:
        HTTPException: If plant name already exists
    """
    logger.debug(f"Adding new plant: {plant.name}")

    # Check for existing plants with same name (case-insensitive)
    existing = (
        db.query(models.Plant)
        .filter(models.Plant.name.ilike(plant.name.strip()))
        .first()
    )

    if existing:
        logger.warning(f"Duplicate plant name found: {plant.name}")
        raise HTTPException(
            status_code=400, detail="Plant with this name already exists"
        )

    try:
        # Create new database model instance with cleaned data
        db_plant = models.Plant(
            name=plant.name.strip(),
            description=plant.description.strip(),
            watering_schedule=plant.watering_schedule.strip(),
        )

        # Add to database and commit transaction
        db.add(db_plant)
        db.commit()
        db.refresh(db_plant)

        logger.info(f"Successfully added plant: {db_plant.name} (ID: {db_plant.id})")
        return db_plant

    except Exception as e:
        # Roll back transaction on error
        db.rollback()
        logger.error(f"Database error while adding plant: {str(e)}")
        raise HTTPException(status_code=500, detail="Database error occurred")


# PUT endpoint to update plant by ID in PostgreSQL
# Route: PUT /api/v1/plants/id/{plant_id}
@router.put("/plants/id/{plant_id}", response_model=PlantSchema)
async def update_plant_by_id(
    plant_id: int, updated_plant: PlantSchema, db: Session = Depends(get_db)
):
    """
    Updates an existing plant in PostgreSQL by ID.

    Args:
        plant_id (int): Database ID of plant to update
        updated_plant (PlantSchema): New plant data
        db (Session): Database session

    Returns:
        PlantSchema: Updated plant data

    Raises:
        HTTPException: If plant not found or name conflict
    """
    logger.debug(f"Updating plant ID: {plant_id}")

    # Find existing plant in database
    db_plant = db.query(models.Plant).filter(models.Plant.id == plant_id).first()
    if not db_plant:
        logger.debug(f"Plant ID {plant_id} not found")
        raise HTTPException(status_code=404, detail="Plant not found")

    # Check for name conflicts (excluding current plant)
    name_conflict = (
        db.query(models.Plant)
        .filter(
            models.Plant.name.ilike(updated_plant.name.strip()),
            models.Plant.id != plant_id,
        )
        .first()
    )

    if name_conflict:
        logger.warning(f"Name conflict found: {updated_plant.name}")
        raise HTTPException(
            status_code=400, detail="Another plant with this name already exists"
        )

    try:
        # Update plant in database
        db_plant.name = updated_plant.name.strip()
        db_plant.description = updated_plant.description.strip()
        db_plant.watering_schedule = updated_plant.watering_schedule.strip()
        db.commit()
        db.refresh(db_plant)

        logger.info(f"Successfully updated plant ID {plant_id}")
        return db_plant

    except Exception as e:
        db.rollback()
        logger.error(f"Database error updating plant: {str(e)}")
        raise HTTPException(status_code=500, detail="Database error occurred")


# PUT endpoint to update plant by name in PostgreSQL
# Route: PUT /api/v1/plants/name/{plant_name}
@router.put("/plants/name/{plant_name}", response_model=PlantSchema)
async def update_plant_by_name(
    plant_name: str, updated_plant: PlantSchema, db: Session = Depends(get_db)
):
    """
    Updates an existing plant in PostgreSQL by name.

    Args:
        plant_name (str): Current name of plant to update
        updated_plant (PlantSchema): New plant data
        db (Session): Database session

    Returns:
        PlantSchema: Updated plant data

    Raises:
        HTTPException: If plant not found or name conflict
    """
    logger.debug(f"Updating plant named: {plant_name}")

    # Find existing plant by name
    db_plant = (
        db.query(models.Plant)
        .filter(models.Plant.name.ilike(plant_name.strip()))
        .first()
    )

    if not db_plant:
        logger.debug(f"Plant named '{plant_name}' not found")
        raise HTTPException(status_code=404, detail="Plant not found")

    # Check for name conflicts if name is being changed
    if plant_name.strip().lower() != updated_plant.name.strip().lower():
        name_conflict = (
            db.query(models.Plant)
            .filter(models.Plant.name.ilike(updated_plant.name.strip()))
            .first()
        )

        if name_conflict:
            logger.warning(f"Name conflict found: {updated_plant.name}")
            raise HTTPException(
                status_code=400, detail="Another plant with this name already exists"
            )

    try:
        # Update plant in database
        db_plant.name = updated_plant.name.strip()
        db_plant.description = updated_plant.description.strip()
        db_plant.watering_schedule = updated_plant.watering_schedule.strip()
        db.commit()
        db.refresh(db_plant)

        logger.info(f"Successfully updated plant: {db_plant.name}")
        return db_plant

    except Exception as e:
        db.rollback()
        logger.error(f"Database error updating plant: {str(e)}")
        raise HTTPException(status_code=500, detail="Database error occurred")


# DELETE endpoint to remove a plant by ID in PostgreSQL
# Route: DELETE /api/v1/plants/id/{plant_id}
@router.delete("/plants/id/{plant_id}", status_code=204)
async def delete_plant_by_id(plant_id: int, db: Session = Depends(get_db)):
    """
    Deletes a plant from the PostgreSQL database by its ID.

    Args:
        plant_id (int): Database ID of the plant to delete
        db (Session): Database session

    Returns:
        None (204 No Content)

    Raises:
        HTTPException: If plant not found
    """
    logger.debug(f"Attempting to delete plant with ID: {plant_id}")
    db_plant = db.query(models.Plant).filter(models.Plant.id == plant_id).first()
    if not db_plant:
        logger.debug(f"Plant ID {plant_id} not found for deletion")
        raise HTTPException(status_code=404, detail="Plant not found")
    try:
        db.delete(db_plant)
        db.commit()
        logger.info(f"Successfully deleted plant with ID: {plant_id}")
    except Exception as e:
        db.rollback()
        logger.error(f"Database error deleting plant: {str(e)}")
        raise HTTPException(status_code=500, detail="Database error occurred")
    return


# DELETE endpoint to remove a plant by name in PostgreSQL
# Route: DELETE /api/v1/plants/name/{plant_name}
@router.delete("/plants/name/{plant_name}", status_code=204)
async def delete_plant_by_name(plant_name: str, db: Session = Depends(get_db)):
    """
    Deletes a plant from the PostgreSQL database by its name.

    Args:
        plant_name (str): Name of the plant to delete
        db (Session): Database session

    Returns:
        None (204 No Content)

    Raises:
        HTTPException: If plant not found
    """
    logger.debug(f"Attempting to delete plant with name: {plant_name}")
    db_plant = (
        db.query(models.Plant)
        .filter(models.Plant.name.ilike(plant_name.strip()))
        .first()
    )
    if not db_plant:
        logger.debug(f"Plant named '{plant_name}' not found for deletion")
        raise HTTPException(status_code=404, detail="Plant not found")
    try:
        db.delete(db_plant)
        db.commit()
        logger.info(f"Successfully deleted plant with name: {plant_name}")
    except Exception as e:
        db.rollback()
        logger.error(f"Database error deleting plant: {str(e)}")
        raise HTTPException(status_code=500, detail="Database error occurred")
    return
